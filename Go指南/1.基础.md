# 基础

Go 的基本类型有

```
bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

byte // uint8 的别名

rune // int32 的别名
     // 表示一个 Unicode 码位

float32 float64

complex64 complex128
```

# 结构体、切片和映射

## 指针

指针保存了值的`内存地址`，**没有指针运算**。

`&` 操作符会生成一个指向其操作数的指针

`*` 操作符表示指针指向的底层值

```go
package main

import "fmt"

func main() {
    i, j := 42, 2701

    p := &i         // 指向 i
    fmt.Println(*p) // 通过指针读取 i 的值 42
    *p = 21         // 通过指针设置 i 的值
    fmt.Println(i)  // 查看 i 的值 21

    p = &j         // 指向 j
    *p = *p / 37   // 通过指针对 j 进行除法运算
    fmt.Println(j) // 查看 j 的值 73

}
```

## 结构体指针

```go
package main

import "fmt"

type Vertex struct {
    X int
    Y int
}

func main() {
    v := Vertex{1, 2}
    p := &v
    p.X = 1e9
    fmt.Println(v) // {1000000000 2}
}
```

## 结构体字面量

```go
package main

import "fmt"

type Vertex struct {
    X, Y int
}

var (
    v1 = Vertex{1, 2}  // 创建一个 Vertex 类型的结构体
    v2 = Vertex{X: 1}  // Y:0 被隐式地赋予零值
    v3 = Vertex{}      // X:0 Y:0
    p  = &Vertex{1, 2} // 创建一个 *Vertex 类型的结构体（指针）
)

func main() {
    fmt.Println(v1, p, v2, v3) // {1 2} &{1 2} {1 0} {0 0}
}
```

## 数组

类型 [n]T 表示一个数组，它拥有 n 个类型为 T 的值。

表达式

```go
var a [10]int
```

数组的长度是其类型的一部分，因此**数组不能改变大小**。

## 切片

每个数组的大小都是固定的。而切片则为数组元素提供了动态大小的、灵活的视角。

类型 []T 表示一个元素类型为 T 的切片。

切片通过两个下标来界定，一个下界和一个上界，二者以冒号分隔：

```go
a[low : high]
```

它会选出一个半闭半开区间，包括第一个元素，但排除最后一个元素。

以下表达式创建了一个切片，它包含 a 中下标从 1 到 3 的元素：

```go
a[1:4]
```

```go
package main

import "fmt"

func main() {
    primes := [6]int{2, 3, 5, 7, 11, 13}

    var s []int = primes[1:4]
    fmt.Println(s) // [3 5 7]
}
```

## 切片类似数组的引用

切片就像数组的引用 切片并不存储任何数据，它只是描述了底层数组中的一段。

更改切片的元素会修改其底层数组中对应的元素。

和它共享底层数组的切片都会观测到这些修改。

```go
package main

import "fmt"

func main() {
    names := [4]string{
        "John",
        "Paul",
        "George",
        "Ringo",
    }
    fmt.Println(names)  // [John Paul George Ringo]

    a := names[0:2]
    b := names[1:3]
    fmt.Println(a, b)   // [John Paul] [Paul George]

    b[0] = "XXX"
    fmt.Println(a, b)   // [John XXX] [XXX George]
    fmt.Println(names)  // [John XXX George Ringo]
}
```

## 切片字面量

切片字面量类似于没有长度的数组字面量。

```go
// 数组字面量，值类型，在赋值或传参时会复制整个数组。
// 类型 [3]bool
[3]bool{true, true, false}
// 创建一个匿名数组 [3]bool，然后再创建一个引用这个数组的切片。这个切片是引用类型，包括：一个指向底层数组的指针、长度、容量
// 类型 []bool
[]bool{true, true, false}   
```

## 切片的默认行为

切片下界的默认值为 0，上界则是该切片的长度。

```go
// low：开始索引，包含，默认0 
// high：结束索引，不包含，默认len(a)
a[low : high]
```

```go
// 数组
var a [10]int

a[0:10]   // 显式指定下界和上界
a[:10]    // 默认下界为 0
a[0:]     // 默认上界为 len(a) = 10
a[:]      // 同时使用两个默认值

// 它们都会返回一个 []int 类型的切片，底层仍引用 a 这个数组。
```

```go
package main

import "fmt"

func main() {
	s := []int{2, 3, 5, 7, 11, 13}

	s = s[1:4]
	fmt.Println(s) // [3 5 7]

	s = s[:2]
	fmt.Println(s) // [3 5]

	s = s[1:]
	fmt.Println(s) // [5]
}
```

## 切片的长度与容量

切片拥有 **长度** 和 **容量**。

切片的长度就是它所包含的元素个数。

切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。

切片 s 的长度和容量可通过表达式 len(s) 和 cap(s) 来获取。

```go
package main

import "fmt"

func main() {
	s := []int{2, 3, 5, 7, 11, 13}
	printSlice(s) // len=6 cap=6 [2 3 5 7 11 13]

    // 如果 cap(s) < 10，就会 panic
    // s = s[:10]
    // panic: runtime error: slice bounds out of range [:10] with capacity 6

	// 截取切片使其长度为 0
	s = s[:0]
	printSlice(s) // len=0 cap=6 []

	// 扩展其长度
	s = s[:4]
	printSlice(s) // len=4 cap=6 [2 3 5 7]

	// 舍弃前两个值
	s = s[2:]
	printSlice(s) // len=2 cap=4 [5 7]
}

func printSlice(s []int) {
	fmt.Printf("len=%d cap=%d %v\n", len(s), cap(s), s)
}
```

## nil 切片

切片的零值是 nil。

nil 切片的长度和容量为 0 且没有底层数组。

```go
package main

import "fmt"

func main() {
	var s []int
	fmt.Println(s, len(s), cap(s)) // [] 0 0
	if s == nil {
		fmt.Println("nil!") // nil!
	}
}
```

## 用 make 创建切片

切片可以用内置函数 make 来创建，这也是你创建动态数组的方式。

make 函数会分配一个元素为零值的数组并返回一个引用了它的切片：

```
a := make([]int, 5)  // len(a)=5
```

要指定它的容量，需向 make 传入第三个参数：

```
b := make([]int, 0, 5) // len(b)=0, cap(b)=5

b = b[:cap(b)] // len(b)=5, cap(b)=5
b = b[1:]      // len(b)=4, cap(b)=4
```

```go
package main

import "fmt"

func main() {
	// 创建一个长度为5的切片，容量也是5，元素初始化为0
	a := make([]int, 5)
	printSlice("a", a) // 输出: a len=5 cap=5 [0 0 0 0 0]

	// 创建一个长度为0、容量为5的切片
	// 这意味着底层数组有5个元素空间，但当前没有使用任何元素
	b := make([]int, 0, 5)
	printSlice("b", b) // 输出: b len=0 cap=5 []

	// 对切片b进行切片操作，取前两个元素（注意：虽然b长度是0，但容量是5，所以合法）
	// 得到一个长度为2、容量为5的新切片c，共享底层数组
	c := b[:2]
	printSlice("c", c) // 输出: c len=2 cap=5 [0 0]

	// 对切片c再次切片，从索引2开始到索引5（不包括5）
	// 虽然c长度为2，但容量为5，所以从索引2起往后还能取3个元素
	// 得到一个长度为3、容量为3的新切片d
	d := c[2:5] // c[2:len(a)] 合理些 c[2:len(c)] 合理&安全

    // 扩展
    // 切片操作 x[i,j] i≥0 j≤cap(x) i≤
    // d := c[2:6]
    // panic: runtime error: slice bounds out of range [:6] with capacity 5
	printSlice("d", d) // 输出: d len=3 cap=3 [0 0 0]
}

// 打印切片的名称、长度、容量和值
func printSlice(s string, x []int) {
	fmt.Printf("%s len=%d cap=%d %v\n",
		s, len(x), cap(x), x)
}
```

## 切片的切片

切片可以包含任何类型，当然也包括其他切片。

```go
package main

import (
	"fmt"
	"strings"
)

func main() {
	// 创建一个 3x3 的二维切片，表示井字棋的棋盘
	// 每一行是一个切片，整个棋盘是由三行组成的切片的切片（二维切片）
	board := [][]string{
		[]string{"_", "_", "_"}, // 第 1 行
		[]string{"_", "_", "_"}, // 第 2 行
		[]string{"_", "_", "_"}, // 第 3 行
	}

	// 玩家轮流落子（X 和 O），模拟一个简单的对局过程
	board[0][0] = "X" // 第 1 行第 1 列放 X
	board[2][2] = "O" // 第 3 行第 3 列放 O
	board[1][2] = "X" // 第 2 行第 3 列放 X
	board[1][0] = "O" // 第 2 行第 1 列放 O
	board[0][2] = "X" // 第 1 行第 3 列放 X

	// 打印棋盘
	for i := 0; i < len(board); i++ {
		// 使用 strings.Join 将一行的 3 个字符串连接成一个用空格分隔的字符串
		fmt.Printf("%s\n", strings.Join(board[i], " "))
	}
}
```

```
X _ X
O _ X
_ _ O
```

## 向切片追加元素

为切片追加新的元素是种常见的操作，为此 Go 提供了内置的 append 函数。

```
func append(s []T, vs ...T) []T
```

append 的第一个参数 s 是一个元素类型为 T 的切片，其余类型为 T 的值将会追加到该切片的末尾。

append 的结果是一个包含原切片所有元素加上新添加元素的切片。

当 s 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。 返回的切片会指向这个新分配的数组。

```go
package main

import "fmt"

func main() {
	var s []int
	printSlice(s) // 初始空切片，len=0 cap=0，底层数组不存在

	// 在空切片上追加一个元素0
	// 由于容量为0，append会分配一个新数组（一般容量从1开始）
	s = append(s, 0)
	printSlice(s) // len=1 cap=1 [0]

	// 再追加一个元素1
	// 当前容量是1，已满，append需要扩容，通常容量会翻倍为2
	s = append(s, 1)
	printSlice(s) // len=2 cap=2 [0 1]

	// 一次追加三个元素2, 3, 4
	// 目前容量2，不足以容纳新增3个元素
	// append会扩容，容量增长到至少5，一般按2倍扩容到6（或更大）
	s = append(s, 2, 3, 4)
	printSlice(s) // len=5 cap=6 [0 1 2 3 4]

	// 再追加一个元素5
	// 当前容量是6，容量足够容纳新元素，无需扩容
	s = append(s, 5)
	printSlice(s) // len=6 cap=6 [0 1 2 3 4 5]

	// 再追加两个元素6, 7
	// 当前容量6，长度6，已满，需要扩容
	// 扩容后容量可能变为12（通常是之前容量的2倍）
	s = append(s, 6, 7)
	printSlice(s) // len=8 cap=12 [0 1 2 3 4 5 6 7]
}

func printSlice(s []int) {
	// 打印切片的长度len，容量cap，以及具体元素
	fmt.Printf("len=%d cap=%d %v\n", len(s), cap(s), s)
}
```

## range 遍历

for 循环的 range 形式可遍历切片或映射。

当使用 for 循环遍历切片时，每次迭代都会返回两个值。 第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。

```go
package main

import "fmt"

// pow 是一个整数切片，包含2的幂次方
var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}

func main() {
	// 使用 for ... range 遍历切片 pow
	// range 每次返回两个值：
	// i 是当前元素的下标（索引）
	// v 是该下标元素的一份副本（值类型）
	for i, v := range pow {
		// 打印当前元素的指数和对应值
		fmt.Printf("2**%d = %d\n", i, v)
		v = v * 2  // 修改副本 v 的值，切片本身不会变
		fmt.Printf("索引 %d 的元素修改为 %d（副本）\n", i, v)
	}
}
```

```go
package main

import "fmt"

// pow 是一个整数切片，包含2的幂次方
var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}

func main() {
	fmt.Println("修改前的切片:", pow)

	// 使用 range 遍历，同时用索引 i 修改切片元素
	for i, v := range pow {
		pow[i] = v * 2 // 直接修改切片元素
	}

	fmt.Println("修改后的切片:", pow)
}
```

## range 遍历（续）

可以将下标或值赋予 _ 来忽略它。

```go
for i, _ := range pow
for _, value := range pow
```

若你只需要索引，忽略第二个变量即可。

```go
for i := range pow
```

```go
package main

import "fmt"

func main() {
	// 创建一个长度为10的切片，初始元素都是0
	pow := make([]int, 10)

	// 只用索引 i，忽略元素值，用 range 遍历切片
	// 为每个元素赋值 2 的 i 次方，即 1 << i
	for i := range pow {
		pow[i] = 1 << uint(i) // 位移运算，相当于 2**i
	}

	// 只用元素值，忽略索引，用 _ 占位符
	for _, value := range pow {
		fmt.Printf("%d\n", value)
	}
}
```

## 练习：切片

实现 Pic。它应当返回一个长度为 `dy` 的切片，其中每个元素是一个长度为 `dx`，元素类型为 `uint8` 的切片。当你运行此程序时，它会将每个整数解释为灰度值 （好吧，其实是蓝度值）并显示它所对应的图像。

图像的解析式由你来定。几个有趣的函数包括 `(x+y)/2`、`x*y`、`x^y`、`x*log(y)` 和 `x%(y+1)`。

（提示：需要使用循环来分配 `[][]uint8` 中的每个 `[]uint8`。）

（请使用 `uint8(intValue)` 在类型之间转换；你可能会用到 `math` 包中的函数。）

```go
package main

import (
	"math"

	"golang.org/x/tour/pic"
)


// Pic 返回 dy 行 dx 列的二维切片，元素为 uint8 的灰度值
func Pic(dx, dy int) [][]uint8 {
	img := make([][]uint8, dy)

	for y := 0; y < dy; y++ {
		row := make([]uint8, dx)
		for x := 0; x < dx; x++ {
			v := float64(x) * math.Log(float64(y+1))
			row[x] = uint8(v)
		}
		img[y] = row
	}

	return img
}

func main() {
	pic.Show(Pic)
}
```

### math.Log

```
func Log(x float64) float64
```
  
参数

* x 是一个 float64 类型的正实数。

* 返回值
返回 `x` 的自然对数，也就是满足下面关系的数 `y`：

$$
e^y = x
$$

其中 $e \approx 2.71828$ 是自然常数。


注意

* 参数不能是负数或 0，否则结果是 NaN 或 -Inf。
* 如果你想用其它底数的对数，可以用换底公式，比如：

  $$
  \log_b x = \frac{\ln x}{\ln b}
  $$

  对应代码：

  ```go
  func LogBase(x, base float64) float64 {
      return math.Log(x) / math.Log(base)
  }
  ```

## Map 映射

`map` 映射将键映射到值。

映射的零值为 `nil` 。`nil` 映射既没有键，也不能添加键。

make 函数会返回给定类型的映射，并将其初始化备用。

```go
package main

import "fmt"

// Vertex 定义了一个结构体，包含经纬度信息
type Vertex struct {
	Lat, Long float64
}

// 声明一个变量 m，类型是 map，
// key 类型是 string，value 类型是 Vertex 结构体
var m map[string]Vertex

func main() {
	// 使用 make 创建一个 map，给 m 分配内存并初始化
	// 不能直接向 nil map 添加元素，会 panic。必须用 make 初始化。
	m = make(map[string]Vertex)

	// 向 map 添加键值对，键是 "Bell Labs"，值是 Vertex 结构体
	m["Bell Labs"] = Vertex{
		40.68433, -74.39967,
	}

	// 访问并打印键 "Bell Labs" 对应的值
	fmt.Println(m["Bell Labs"])

	// map 的键是唯一的
	m["Bell Labs"] = Vertex{
		41.68433, -73.39967,
	}

	// 访问并打印键 "Bell Labs" 对应的值
	fmt.Println(m["Bell Labs"])
}
```

额外提示

你也可以写成下面这样更简洁：

```go
m := map[string]Vertex{
    "Bell Labs": {40.68433, -74.39967},
}
fmt.Println(m["Bell Labs"])
```

## 映射字面量

映射的字面量和结构体类似，只不过必须有键名。

```go
package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

var m = map[string]Vertex{
	"Bell Labs": Vertex{
		40.68433, -74.39967,
	},
	"Google": Vertex{
		37.42202, -122.08408,
	},
}

func main() {
	fmt.Println(m)
}
```

## 映射字面量（续）

若顶层类型只是一个类型名，那么你可以在字面量的元素中省略它。

```go
package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

var m = map[string]Vertex{
	"Bell Labs": {40.68433, -74.39967},
	"Google":    {37.42202, -122.08408},
}

func main() {
	fmt.Println(m)
}
```

## 修改映射

在映射 `m` 中插入或修改元素：

```go
m[key] = elem
```

获取元素：

```go
elem = m[key]
```

删除元素：

```go
delete(m, key)
```

通过双赋值检测某个键是否存在：

```go
elem, ok = m[key]
```

若 `key` 在 `m` 中，`ok` 为 `true` ；否则，`ok` 为 `false`。

若 key 不在映射中，则 elem 是该映射元素类型的零值。

**注**：若 `elem` 或 `ok` 还未声明，你可以使用短变量声明：

```go
elem, ok := m[key]
```

```go
package main

import "fmt"

func main() {
	// 创建一个空的 map，键为 string，值为 int
	m := make(map[string]int)

	// 插入键值对 "答案": 42
	m["答案"] = 42
	fmt.Println("值：", m["答案"]) // 输出：值： 42

	// 修改键 "答案" 对应的值为 48
	m["答案"] = 48
	fmt.Println("值：", m["答案"]) // 输出：值： 48

	// 删除键 "答案"
	delete(m, "答案")
	// 尝试访问被删除的键，返回该值类型的零值（int 类型零值是 0）
	fmt.Println("值：", m["答案"]) // 输出：值： 0

	// 双赋值检测键是否存在
	v, ok := m["答案"]
	// 判断键是否存在，ok 为 true 表示存在，否则不存在
	if ok {
		fmt.Println("键存在，值为：", v)
	} else {
		fmt.Println("键不存在")
	}
}
```

## 练习：映射

实现 WordCount。它应当返回一个映射，其中包含字符串 s 中每个“单词”的个数。 函数 wc.Test 会为此函数执行一系列测试用例，并输出成功还是失败。

你会发现 `strings.Fields` 很有用。

```go
package main

import (
	"strings"

	"golang.org/x/tour/wc"
)

// WordCount 返回字符串 s 中每个单词出现的次数的映射
func WordCount(s string) map[string]int {
	words := strings.Fields(s) // 按空白字符拆分单词
	counts := make(map[string]int)

	for _, w := range words {
		counts[w]++ // 统计单词出现次数，默认零值为0，++ 后自动加1
	}

	return counts
}

func main() {
	wc.Test(WordCount)
}
```

## 函数值

函数也是值。它们可以像其他值一样传递。

函数值可以用作函数的参数或返回值。

```go
package main

import (
	"fmt"
	"math"
)

// compute 接受一个函数 fn，参数是两个 float64，返回 float64
// compute 调用传入的函数 fn，传入固定参数 3 和 4，返回结果
func compute(fn func(float64, float64) float64) float64 {
	return fn(3, 4)
}

func main() {
	// 定义一个匿名函数 hypot，计算直角三角形斜边长
	hypot := func(x, y float64) float64 {
		return math.Sqrt(x*x + y*y)
	}

	// 直接调用 hypot 计算 5 和 12 的斜边长，输出 13
	fmt.Println(hypot(5, 12))

	// 将 hypot 函数作为参数传给 compute，传入 3 和 4，计算斜边长 5
	fmt.Println(compute(hypot))

	// 直接传入 math.Pow 作为参数，计算 3 的 4 次方，输出 81
	fmt.Println(compute(math.Pow))
}
```


## 函数闭包

Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。 该函数可以访问并赋予其引用的变量值，换句话说，该函数被“绑定”到了这些变量。

例如，函数 `adder` 返回一个闭包。每个闭包都被绑定在其各自的 `sum` 变量上。

* 闭包（Closure）简介

	闭包是一个函数值，它捕获并“绑定”了其外部作用域的变量。即使这个外部函数已经返回了，闭包依然可以访问和修改这些被捕获的变量。

```go
package main

import "fmt"

// adder 返回一个闭包函数，这个闭包会累加传入的整数并返回当前的和
func adder() func(int) int {
	sum := 0               // 定义局部变量 sum，保存累计和，初始为 0
	return func(x int) int { // 返回一个匿名函数，匿名函数是一个闭包
		sum += x          // 匿名函数访问并修改外部变量 sum，实现累加功能
		return sum        // 返回当前的累计和
	}
}

func main() {
	pos, neg := adder(), adder() // 创建两个独立的闭包，每个闭包维护自己的 sum 变量

	for i := 0; i < 10; i++ {
		// 每次循环分别调用 pos 和 neg 闭包
		// pos 累加 i，neg 累加 -2*i
		fmt.Println(
			pos(i),     // 调用 pos，输出累计的正数和
			neg(-2*i),  // 调用 neg，输出累计的负数和
		)
	}
}
```

```
3 -6
6 -12
10 -20
15 -30
21 -42
28 -56
36 -72
45 -90
```


## 练习：斐波纳契闭包

让我们用函数做些好玩的。

实现一个 fibonacci 函数，它返回一个函数（闭包），该闭包返回一个[斐波纳契数列](https://zh.wikipedia.org/wiki/斐波那契数) (0, 1, 1, 2, 3, 5, ...)。

```go
package main

import "fmt"

// fibonacci 返回一个返回 int 的函数，生成斐波那契数列
func fibonacci() func() int {
	a, b := 0, 1
	return func() int {
		// 返回当前的 a，并更新 a, b 为下一个斐波那契数
		result := a
		a, b = b, a+b
		return result
	}
}

func main() {
	f := fibonacci()
	for i := 0; i < 10; i++ {
		fmt.Println(f())
	}
}
```