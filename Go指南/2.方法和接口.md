# 方法和接口

## 方法

 Go 没有类。不过你可以为类型定义方法。

方法就是一类带特殊的 `接收者` 参数的函数。

方法接收者在它自己的参数列表内，位于 func 关键字和方法名之间。 

```go
package main

import (
	"fmt"
	"math"
)

// Vertex 表示一个二维点
type Vertex struct {
	X, Y float64
}

// Abs 返回点到原点的距离
func (v Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	v := Vertex{3, 4}
	fmt.Println(v.Abs()) // 输出: 5
}

```

## 方法即函数

记住：方法只是个带接收者参数的函数。 

```go
package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

func Abs(v Vertex) float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	v := Vertex{3, 4}
	fmt.Println(Abs(v))
}
```

## 方法（续）

你也可以为非结构体类型声明方法。

在此例中，我们看到了一个带 Abs 方法的数值类型 MyFloat。

你只能为在同一个包中定义的接收者类型声明方法，而不能为其它别的包中定义的类型 （包括 int 之类的内置类型）声明方法。

（注：就是接收者的类型定义和方法声明必须在同一包内。） 

```go
package main

import (
	"fmt"
	"math"
)

type MyFloat float64

func (f MyFloat) Abs() float64 {
	if f < 0 {
		return float64(-f)
	}
	return float64(f)
}

func main() {
	f := MyFloat(-math.Sqrt2)
	fmt.Println(f.Abs()) // 1.4142135623730951
}
```

## 指针类型的接收者

 你可以为指针类型的接收者声明方法。

这意味着对于某类型 `T`，接收者的类型可以用 `*T` 的文法。 （此外，T 本身不能是指针，比如不能是 *int。）

例如，这里为 `*Vertex` 定义了 `Scale` 方法。

指针接收者的方法可以修改接收者指向的值（如这里的 `Scale` 所示）。 由于方法经常需要修改它的接收者，指针接收者比值接收者更常用。

试着移除第 16 行 `Scale` 函数声明中的 `*`，观察此程序的行为如何变化。

若使用值接收者，那么 `Scale` 方法会对原始 `Vertex` 值的副本进行操作。（对于函数的其它参数也是如此。）`Scale` 方法必须用指针接收者来更改 `main` 函数中声明的 `Vertex` 的值。 

```go
package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

// 计算距离，不修改数据，用值接收者
func (v Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

// 缩放坐标，修改数据，需要用指针接收者
func (v *Vertex) Scale(f float64) { // 移除 * 打印 5
	v.X = v.X * f
	v.Y = v.Y * f
}

func main() {
	v := Vertex{3, 4}
	v.Scale(10) // 使用指针接收者的方法
	fmt.Println(v.Abs()) // 输出: 50
}
```

## 指针与函数

```go
package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

// 独立函数：计算绝对值
func Abs(v Vertex) float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

// 独立函数：缩放
func Scale(v *Vertex, f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}

func main() {
	v := Vertex{3, 4}
	Scale(&v, 10)
	fmt.Println(Abs(v)) // 输出: 50
}
```

| 维度         | 函数 (`func`)              | 方法 (`func (T)`)                               |
| ------------ | -------------------------- | ----------------------------------------------- |
| 定义方式     | `func 函数名(参数) 返回值` | `func (接收者) 方法名(参数) 返回值`             |
| 是否绑定类型 | 否                         | 是，绑定到某个类型                              |
| 调用方式     | `函数名(参数)`             | `实例.方法名(参数)`                             |
| 是否修改实例 | 需要传指针参数             | 用指针接收者 (`*T`) 可修改，值接收者 (`T`) 不行 |
| 适用场景     | 通用工具、与类型无关的操作 | 属于某个类型的行为、需要对结构体进行操作        |
| 示例         | `Abs(v Vertex)`            | `(v Vertex) Abs()`                              |


**简明总结（建议你记住这两条）**

| 选择方式     | 场景示例             | 举例                                      |
| ------------ | -------------------- | ----------------------------------------- |
| **写成函数** | 通用逻辑、无特定归属 | `Abs(v Vertex)`、`Scale(v *Vertex, f)`    |
| **写成方法** | 属于某个类型的行为   | `(v Vertex) Abs()`、`(v *Vertex) Scale()` |

```
方法做行为，函数做工具。
值接收者不改数据，指针接收者能改结构。
```

## 方法与指针重定向

比较前两个程序，你大概会注意到带指针参数的函数必须接受一个指针：

```go
var v Vertex
ScaleFunc(v, 5)  // 编译错误！
ScaleFunc(&v, 5) // OK
```

而接收者为指针的的方法被调用时，接收者既能是值又能是指针：

```go
var v Vertex
v.Scale(5)  // OK
p := &v
p.Scale(10) // OK
```

对于语句 `v.Scale(5)` 来说，即便 v 是一个值而非指针，带指针接收者的方法也能被直接调用。 也就是说，由于 `Scale` 方法有一个指针接收者，为方便起见，Go 会将语句 `v.Scale(5)` 解释为 `(&v).Scale(5)`。 

```go
package main

import "fmt"

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Scale(f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}

func ScaleFunc(v *Vertex, f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}

func main() {
	v := Vertex{3, 4}
    
    // 方法接收者为 *Vertex，但这里用 v (值类型) 调用，Go 自动帮你补 &v
    v.Scale(2)       // 自动转为 (&v).Scale(2)
    
    // 函数要求传指针，必须手动取地址
    ScaleFunc(&v, 10)

    // p 是 *Vertex，直接调用方法
    p := &Vertex{4, 3}
    p.Scale(3)       // 直接调用，无需额外处理
    ScaleFunc(p, 8)  // 直接调用

    fmt.Println(v, p)
}
```

## 方法与指针重定向（续）

 反之也一样：

接受一个值作为参数的函数必须接受一个指定类型的值：

```go
var v Vertex
fmt.Println(AbsFunc(v))  // OK
fmt.Println(AbsFunc(&v)) // 编译错误！
```

而以值为接收者的方法被调用时，接收者既能为值又能为指针：

```go
var v Vertex
fmt.Println(v.Abs()) // OK
p := &v
fmt.Println(p.Abs()) // OK
```

这种情况下，方法调用 p.Abs() 会被解释为 (*p).Abs()。 


```go
package main

import (
	"fmt"
	"math"
)

// 定义结构体 Vertex
type Vertex struct {
	X, Y float64
}

// 方法：值接收者
func (v Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

// 函数：值参数
func AbsFunc(v Vertex) float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	v := Vertex{3, 4}

	// 方法调用：v 是值，OK
	fmt.Println(v.Abs())      // 5

	// 函数调用：v 是值，OK
	fmt.Println(AbsFunc(v))   // 5

	p := &Vertex{4, 3}

	// 方法调用：p 是指针，OK（自动解引用为 (*p).Abs()）
	fmt.Println(p.Abs())      // 5

	// 函数调用：必须传值，*p 表示解引用为值
	fmt.Println(AbsFunc(*p))  // 5
}
```

| 场景                 | 说明                                        | 示例                                                |
| -------------------- | ------------------------------------------- | --------------------------------------------------- |
| **函数接收值参数**   | 必须传入值，不能传指针                      | `AbsFunc(v)` OK，`AbsFunc(&v)` 编译错误             |
| **方法接收值参数**   | 调用时可以是值，也可以是指针，Go 自动处理   | `v.Abs()` OK，`p.Abs()` OK（等价于 `(*p).Abs()`）   |
| **函数接收指针参数** | 必须传入指针，不能传值                      | `ScaleFunc(&v)` OK，`ScaleFunc(v)` 编译错误         |
| **方法接收指针参数** | 调用时可以是值，也可以是指针，Go 自动取地址 | `v.Scale()` 自动转为 `(&v).Scale()`，`p.Scale()` OK |

```
函数要求严格，类型必须一致。
方法更灵活，自动帮你取地址。
结构体的行为封装为方法，通用逻辑封装为函数
```

## 选择值或指针作为接收者

 使用指针接收者的原因有二：

首先，方法能够修改其接收者指向的值。

其次，这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样会更加高效。

在本例中，Scale 和 Abs 接收者的类型为 *Vertex，即便 Abs 并不需要修改其接收者。

通常来说，所有给定类型的方法都应该有值或指针接收者，但并不应该二者混用


```go
package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Scale(f float64) {
	// 修改了接收者指向的值
	v.X = v.X * f
	v.Y = v.Y * f
}

func (v *Vertex) Abs() float64 {
	// 只读取值，计算距离
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	v := &Vertex{3, 4} 
	// v 是指向 Vertex 的指针
	fmt.Printf("缩放前：%+v，绝对值：%v\n", v, v.Abs())
	v.Scale(5)
	fmt.Printf("缩放后：%+v，绝对值：%v\n", v, v.Abs())
}
```


## 接口

**接口类型** 的定义为一组方法签名。

接口类型的变量可以持有任何实现了这些方法的值。

**注意**: 示例代码的第 22 行存在一个错误。由于 Abs 方法只为 *Vertex （指针类型）定义，因此 Vertex（值类型）并未实现 Abser。

```go
package main

import (
	"fmt"
	"math"
)

type Abser interface {
	Abs() float64
}

func main() {
	var a Abser
	f := MyFloat(-math.Sqrt2)
	v := Vertex{3, 4}

	a = f  // a MyFloat 实现了 Abser
	a = &v // a *Vertex 实现了 Abser

	// 下面一行，v 是一个 Vertex（而不是 *Vertex）
	// 所以没有实现 Abser。
	// a = v // 错误 因为 Vertex 类型并没有实现接口 Abser

	fmt.Println(a.Abs())
}

type MyFloat float64

func (f MyFloat) Abs() float64 {
	if f < 0 {
		return float64(-f)
	}
	return float64(f)
}

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}
```

代码补充说明：
```go
func (v Vertex) Abs() float64 {
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
}
```
这样，`Vertex` 和 `*Vertex` 都实现了接口 `Abser`。

* 值接收者定义的方法，值和指针都能调用，也都实现接口

* 指针接收者定义的方法，只能被指针调用，只有指针实现接口

## 接口与隐式实现

类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有“implements”关键字。

隐式接口从接口的实现中解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备。

因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义。 

```go
package main

import "fmt"

type I interface {
	M()
}

type T struct {
	S string
}

// 此方法表示类型 T 实现了接口 I，不过我们并不需要显式声明这一点。
func (t T) M() {
	fmt.Println(t.S)
}

func main() {
	var i I = T{"hello"}
	i.M() // hello
}
```

## 接口值

 接口也是值。它们可以像其它值一样传递。

接口值可以用作函数的参数或返回值。

在内部，接口值可以看做包含值和具体类型的元组：

```go
(value, type)
```

接口值保存了一个具体底层类型的具体值。

接口值调用方法时会执行其底层类型的同名方法。 

```go
package main

import (
	"fmt"
	"math"
)

type I interface {
	M()
}

type T struct {
	S string
}

// (*T).M 方法，指针接收者
func (t *T) M() {
	fmt.Println(t.S) // 打印 T 结构体的字段 S，比如 "Hello"
}

type F float64

// F 类型的 M 方法，值接收者
func (f F) M() {
	fmt.Println(f) // 打印 float64 数值，比如 3.141592653589793
}

func main() {
	var i I

	i = &T{"Hello"} // i 保存了具体类型 *T 和值 &{Hello}
	describe(i)     // 打印接口内部存储的值和值的类型: (&{Hello}, *main.T)
	i.M()           // 调用 *T 的 M() 方法，输出 "Hello"

	i = F(math.Pi)  // i 保存了具体类型 F 和值 3.141592653589793
	describe(i)     // 打印接口内部存储的值和值的类型: (3.141592653589793, main.F)
	i.M()           // 调用 F 的 M() 方法，输出 3.141592653589793
}

// describe 函数打印接口的底层值和类型
func describe(i I) {
	fmt.Printf("(%v, %T)\n", i, i)
}
```

## 底层值为 nil 的接口值

 即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用。

在一些语言中，这会触发一个空指针异常，但在 Go 中通常会写一些方法来优雅地处理它（如本例中的 M 方法）。

**注意**: 保存了 nil 具体值的接口其自身并不为 nil。 

```go
package main

import "fmt"

// 定义接口 I，包含一个方法 M
type I interface {
	M()
}

// 定义结构体 T，包含一个字符串字段 S
type T struct {
	S string
}

// 为 *T 指针类型实现接口 I 的方法 M
func (t *T) M() {
	// 判断指针是否为 nil，避免空指针访问导致崩溃
	if t == nil {
		fmt.Println("<nil>")
		return
	}
	// 指针非 nil 时，打印结构体字段 S 的值
	fmt.Println(t.S)
}

func main() {
	var i I    // 声明接口变量 i，初始值为 nil

	var t *T   // 声明指针变量 t，类型为 *T，初始值为 nil（指针零值）

	i = t      // 将 nil 指针赋值给接口 i，此时接口的动态类型是 *T，动态值为 nil

	describe(i) // 打印接口变量 i 内部保存的值和值的类型
	i.M()       // 调用接口方法 M，执行的是 (*T).M 方法，t 为 nil，打印 <nil>

	i = &T{"hello"} // 将非 nil 的 *T 指针赋值给接口 i，动态类型仍是 *T，动态值非 nil

	describe(i) // 打印接口变量 i 内部保存的值和值的类型
	i.M()       // 调用接口方法 M，执行的是 (*T).M 方法，t 非 nil，打印 hello
}

// describe 函数接受接口 I 类型参数，打印接口内部保存的值和值的具体类型
func describe(i I) {
	// %v 打印接口保存的值，%T 打印接口保存的具体类型
	fmt.Printf("(%v, %T)\n", i, i)
}
```

## nil 接口值

nil 接口值既不保存值也不保存具体类型。

```go
package main

import "fmt"

type I interface {
	M()
}

func main() {
	var i I       // i 是接口类型 I，初始值为 nil（接口值和接口类型都为 nil）
	describe(i)   // 打印 i 的内容
	// i.M()         // 调用接口方法 M —— 这里会发生运行时错误

    // 解决错误
    if i != nil {
		i.M()
	} else {
		fmt.Println("接口变量是 nil，不能调用方法")
	}
}

func describe(i I) {
	fmt.Printf("(%v, %T)\n", i, i)  // 打印接口的动态值和动态类型
}
```

## 空接口

指定了零个方法的接口值被称为 **空接口**：

```go
interface{}
```

空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。）

空接口被用来处理未知类型的值。例如，fmt.Print 可接受类型为 interface{} 的任意数量的参数。 

```go
package main

import "fmt"

func main() {
	var i interface{}  // 声明空接口变量 i，初始值为 nil（动态值和动态类型都为 nil）
	describe(i)        // 输出：(<nil>, <nil>)，因为此时 i 没有持有任何值和类型

	i = 42             // 给空接口赋值整数 42，此时动态类型为 int，动态值为 42
	describe(i)        // 输出：(42, int)

	i = "hello"        // 给空接口赋值字符串 "hello"，动态类型变为 string，动态值变为 "hello"
	describe(i)        // 输出：(hello, string)
}

// describe 函数打印接口变量的动态值和动态类型
func describe(i interface{}) {
	fmt.Printf("(%v, %T)\n", i, i)
}
```

## 类型断言

**类型断言** 提供了访问接口值底层具体值的方式。

```go
t := i.(T)
```

该语句断言接口值 `i` 保存了具体类型 `T`，并将其底层类型为 `T` 的值赋予变量 `t`。

若 `i` 并未保存 `T` 类型的值，该语句就会触发一个 panic。

为了 **判断** 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。

```go
t, ok := i.(T)
```

若 `i` 保存了一个 `T`，那么 `t` 将会是其底层值，而 `ok` 为 `true`。

否则，`ok` 将为 `false` 而 `t` 将为 `T` 类型的零值，程序并不会产生 `panic`。

请注意这种语法和读取一个映射时的相同之处。 

```go
package main

import "fmt"

func main() {
	var i interface{}

	i = "hello"

	// 安全断言：判断接口 i 是否存储了 string 类型
	if s, ok := i.(string); ok {
		fmt.Println("字符串类型，值为：", s)
	} else {
		fmt.Println("不是字符串类型")
	}

	// 尝试断言为 float64 类型
	if f, ok := i.(float64); ok {
		fmt.Println("float64 类型，值为：", f)
	} else {
		fmt.Println("不是 float64 类型")
	}

	// 直接断言但不安全，会导致 panic
	// f := i.(float64)  // 如果取消注释，程序会 panic
	// fmt.Println(f)
}
```

## 类型选择

**类型选择** 是一种按顺序从几个类型断言中选择分支的结构。

类型选择与一般的 `switch` 语句相似，不过类型选择中的 `case` 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。

```go
switch v := i.(type) {
case T:
    // v 的类型为 T
case S:
    // v 的类型为 S
default:
    // 没有匹配，v 与 i 的类型相同
}
```

类型选择中的声明与类型断言 `i.(T)` 的语法相同，只是具体类型 `T` 被替换成了关键字 `type。`

此选择语句判断接口值 `i` 保存的值类型是 `T` 还是 `S`。在 `T` 或 `S` 的情况下，变量 `v` 会分别按 `T` 或 `S` 类型保存 `i` 拥有的值。在默认（即没有匹配）的情况下，变量 `v` 与 `i` 的接口类型和值相同。 

```go
package main

import "fmt"

// do 函数接收一个空接口类型参数，可以传入任何类型
func do(i interface{}) {
	// 类型选择，根据接口 i 的动态类型执行对应的 case
	switch v := i.(type) {
	case int:
		// 如果是 int 类型，打印数字的两倍
		fmt.Printf("二倍的 %v 是 %v\n", v, v*2)
	case string:
		// 如果是 string 类型，打印字符串内容和长度（字节数）
		fmt.Printf("%q 长度为 %v 字节\n", v, len(v))
	default:
		// 其他类型，打印未知类型和实际类型信息
		fmt.Printf("我不知道类型 %T!\n", v)
	}
}

func main() {
	do(21)       // 传入 int，输出：二倍的 21 是 42
	do("hello")  // 传入 string，输出："hello" 长度为 5 字节
	do(true)     // 传入 bool，输出：我不知道类型 bool!
}
```

## Stringer

`fmt` 包中定义的 `Stringer` 是最普遍的接口之一。

```go
type Stringer interface {
    String() string
}
```

`Stringer` 是一个可以用字符串描述自己的类型。`fmt` 包（还有很多包）都通过此接口来打印值。 

```go
package main

import "fmt"

// 定义 Person 结构体，包含姓名和年龄
type Person struct {
	Name string
	Age  int
}

// 为 Person 类型实现 fmt.Stringer 接口
// String 方法定义了 Person 类型打印时的格式
func (p Person) String() string {
	// 返回格式化字符串，如 "Arthur Dent (42 years)"
	return fmt.Sprintf("%v (%v years)", p.Name, p.Age)
}

func main() {
	a := Person{"Arthur Dent", 42}
	z := Person{"Zaphod Beeblebrox", 9001}

	// fmt.Println 调用时会自动调用 a.String() 和 z.String()，输出自定义格式
	fmt.Println(a, z)
}
```

```go
package main

import (
	"fmt"
	"strings"
)

// Person 结构体
type Person struct {
	Name string
	Age  int
}

// 实现 Stringer 接口，格式化 Person 的输出
func (p Person) String() string {
	return fmt.Sprintf("%v (%v years)", p.Name, p.Age)
}

// Company 结构体，包含公司名称和员工列表
type Company struct {
	Name    string
	Employees []Person
}

// 实现 Stringer 接口，格式化 Company 的输出
func (c Company) String() string {
	// 用 strings.Builder 高效拼接字符串
	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("Company: %s\nEmployees:\n", c.Name))
	for _, emp := range c.Employees {
		sb.WriteString(" - " + emp.String() + "\n") // 调用 Person.String()
	}
	return sb.String()
}

func main() {
	company := Company{
		Name: "Tech Co.",
		Employees: []Person{
			{"Alice", 30},
			{"Bob", 25},
			{"Charlie", 35},
		},
	}

	// fmt.Println 会调用 Company.String()
	fmt.Println(company)
}
```

```go
package main

import (
	"fmt"
)

// 自定义错误类型
type MyError struct {
	When string
	What string
}

// 实现 error 接口的 Error() 方法
func (e *MyError) Error() string {
	return fmt.Sprintf("发生错误时间: %s，错误内容: %s", e.When, e.What)
}

func run(flag bool) error {
	if flag {
		// 返回自定义错误
		return &MyError{
			When: "现在",
			What: "发生了某些问题",
		}
	}
	return nil
}

func main() {
	err := run(true)
	if err != nil {
		// 这里调用了 err.Error()，输出自定义错误信息
		fmt.Println(err)
	} else {
		fmt.Println("运行正常，无错误。")
	}
}
```

## 练习：Stringer

通过让 `IPAddr` 类型实现 `fmt.Stringer` 来打印点号分隔的地址。

例如，`IPAddr{1, 2, 3, 4}` 应当打印为 `"1.2.3.4"`。 

```go
package main

import (
	"fmt"
	"strings"
)

type IPAddr [4]byte

// TODO: 为 IPAddr 添加一个 "String() string" 方法。
// func (ip IPAddr) String() string {
// 	// 将 IP 地址的 4 个字节转为字符串并用 "." 连接
// 	var parts []string
// 	for _, b := range ip {
// 		parts = append(parts, fmt.Sprintf("%d", b))
// 	}
// 	return strings.Join(parts, ".")
// }

func (ip IPAddr) String() string {
	var sb strings.Builder
	for i, b := range ip {
		if i > 0 {
			sb.WriteByte('.') // 每个字节之间加 .
		}
		fmt.Fprintf(&sb, "%d", b) // 向 sb 写入数字
	}
	return sb.String()
}

func main() {
	hosts := map[string]IPAddr{
		"loopback":  {127, 0, 0, 1},
		"googleDNS": {8, 8, 8, 8},
	}
	for name, ip := range hosts {
		fmt.Printf("%v: %v\n", name, ip)
	}
}
```


## 错误

`Go` 程序使用 `error` 值来表示错误状态。

与 `fmt.Stringer` 类似，`error` 类型是一个内建接口：

```go
type error interface {
    Error() string
}
```

（与 `fmt.Stringer` 类似，`fmt` 包也会根据对 `error `的实现来打印值。）

通常函数会返回一个 error 值，调用它的代码应当判断这个错误是否等于 nil 来进行错误处理。

```go
i, err := strconv.Atoi("42")
if err != nil {
    fmt.Printf("couldn't convert number: %v\n", err)
    return
}
fmt.Println("Converted integer:", i)
```

`error` 为 `nil` 时表示成功；非 `nil` 的 `error` 表示失败。

```go
package main

import (
	"fmt"
	"time"
)

// 定义一个自定义错误类型 MyError
type MyError struct {
	When time.Time // 记录错误发生的时间
	What string    // 记录错误的描述
}

// 为 *MyError 实现 error 接口的 Error() 方法
func (e *MyError) Error() string {
	// 返回格式化的错误信息
	return fmt.Sprintf("at %v, %s", e.When, e.What)
}

// run 函数模拟运行并返回一个错误
func run() error {
	// 返回一个自定义错误 MyError
	return &MyError{
		time.Now(),         // 当前时间
		"it didn't work",   // 错误描述
	}
}

func main() {
	// 调用 run 函数，如果有错误则打印
	if err := run(); err != nil {
		// err 实际上是 *MyError 类型的一个实例
		// 因为 *MyError 实现了 error 接口，所以可以作为 error 类型处理
		fmt.Println(err) // 会自动调用 err.Error()
	}
}
```

## 练习：错误

从之前的练习中复制 `Sqrt` 函数，修改它使其返回 `error` 值。

`Sqrt` 接受到一个负数时，应当返回一个非 `nil` 的错误值。复数同样也不被支持。

创建一个新的类型

```go
type ErrNegativeSqrt float64
```

并为其实现

```go
func (e ErrNegativeSqrt) Error() string
```

方法使其拥有 `error` 值，通过 `ErrNegativeSqrt(-2).Error()` 调用该方法应返回 `"cannot Sqrt negative number: -2"`。

注意: 在 `Error` 方法内调用 `fmt.Sprint(e)` 会让程序陷入死循环。可以通过先转换 `e` 来避免这个问题：`fmt.Sprint(float64(e))`。这是为什么呢？

修改 `Sqrt` 函数，使其接受一个负数时，返回 `ErrNegativeSqrt` 值。 


```go
package main

import (
	"fmt"
	"math"
)

// 定义 ErrNegativeSqrt 类型
type ErrNegativeSqrt float64

// 实现 error 接口
func (e ErrNegativeSqrt) Error() string {
	// 注意: e 本身实现了 Error() 方法，如果你直接 fmt.Sprint(e)，会触发 e.Error()，造成无限递归死循环
	// 因此需要将 e 转为 float64，以避免这种问题
	return fmt.Sprintf("cannot Sqrt negative number: %v", float64(e))
}

// Sqrt 函数
func Sqrt(x float64) (float64, error) {
	if x < 0 {
		return 0, ErrNegativeSqrt(x)
	}
	return math.Sqrt(x), nil
}

func main() {
	fmt.Println(Sqrt(2))
	fmt.Println(Sqrt(-2))
}
```

## Readers

`io` 包指定了 `io.Reader` 接口，它表示数据流的读取端。

`Go` 标准库包含了该接口的许多实现，包括文件、网络连接、压缩和加密等等。

`io.Reader` 接口有一个 `Read` 方法：

```go
func (T) Read(b []byte) (n int, err error)
```

`Read` 用数据填充给定的字节切片并返回填充的字节数和错误值。在遇到数据流的结尾时，它会返回一个 `io.EOF `错误。

示例代码创建了一个 `strings.Reader` 并以每次 `8` 字节的速度读取它的输出。 

```go
package main

import (
	"fmt"
	"io"
	"strings"
)

func main() {
	// 创建一个 strings.Reader，底层数据是字符串 "Hello, Reader!"
	r := strings.NewReader("Hello, Reader!")

	// 创建一个 8 字节大小的缓冲区
	b := make([]byte, 8)

	// 循环读取数据，直到遇到 io.EOF
	for {
		// 从 Reader 中读取数据到缓冲区 b
		n, err := r.Read(b)

		// 打印读取到的字节数、错误信息、整个缓冲区的内容
		fmt.Printf("n = %v err = %v b = %v\n", n, err, b)

		// 打印有效读取的字节（b[:n]），以字符串形式显示
		fmt.Printf("b[:n] = %q\n", b[:n])

		// 当读取结束，遇到 EOF 错误时，退出循环
		if err == io.EOF {
			break
		}

		// 如果是其他错误，可以在这里处理
		if err != nil {
			fmt.Println("读取出错:", err)
			break
		}
	}
}
```

## 练习：Reader

实现一个 `Reader` 类型，它产生一个` ASCII` 字符 `'A'` 的无限流。

```go
package main

import (
	"golang.org/x/tour/reader"
)

// 定义 MyReader 类型（空结构体）
type MyReader struct{}

// 实现 io.Reader 接口的 Read 方法
func (r MyReader) Read(b []byte) (int, error) {
	// 将 b 填充为 'A'
	for i := range b {
		b[i] = 'A'
	}
	// 返回写入的字节数和 nil（无错误）
	return len(b), nil
}

func main() {
	// 验证 MyReader 是否满足 io.Reader 接口
	reader.Validate(MyReader{})
}
```

## 练习：rot13Reader

有种常见的模式是一个 `io.Reader` 包装另一个 `io.Reader`，然后通过某种方式修改其数据流。

例如，gzip.NewReader 函数接受一个 `io.Reader`（已压缩的数据流）并返回一个同样实现了 `io.Reader` 的 `*gzip.Reader`（解压后的数据流）。

编写一个实现了 `io.Reader` 并从另一个 `io.Reader` 中读取数据的 `rot13Reader`，通过应用 `rot13` 代换密码对数据流进行修改。

`rot13Reader` 类型已经提供。实现 `Read` 方法以满足 `io.Reader`。 

```go
package main

import (
	"io"
	"os"
	"strings"
)

// 定义 rot13Reader 结构体，嵌套一个 io.Reader
type rot13Reader struct {
	r io.Reader
}

// 实现 io.Reader 接口
func (r *rot13Reader) Read(b []byte) (int, error) {
	// 从原始 reader 读取数据到 b 中
	n, err := r.r.Read(b)
	if err != nil && err != io.EOF {
		return n, err
	}

	// 对读取的前 n 个字节进行 rot13 编码
	for i := 0; i < n; i++ {
		b[i] = rot13(b[i])
	}

	// 返回读取的字节数和错误
	return n, err
}

// rot13 编码函数
func rot13(c byte) byte {
	switch {
	case 'A' <= c && c <= 'Z':
		return 'A' + (c-'A'+13)%26
	case 'a' <= c && c <= 'z':
		return 'a' + (c-'a'+13)%26
	default:
		return c
	}
}

func main() {
	// 创建一个 strings.Reader 并包装为 rot13Reader
	s := strings.NewReader("Lbh penpxrq gur pbqr!")
	r := rot13Reader{s}
	io.Copy(os.Stdout, &r)
}
```

## 图像

`image` 包定义了 `Image` 接口：

```go
package image

type Image interface {
    ColorModel() color.Model
    Bounds() Rectangle
    At(x, y int) color.Color
}
```

注意: `Bounds` 方法的返回值 `Rectangle` 实际上是一个 `image.Rectangle`，它在 `image` 包中声明。

（请参阅[文档](https://go-zh.org/pkg/image/#Image)了解全部信息。）

`color.Color` 和 `color.Model` 类型也是接口，但是通常因为直接使用预定义的实现 `image.RGBA` 和 `image.RGBAModel` 而被忽视了。这些接口和类型由 `image/color` 包定义。

```go
package main

import (
	"fmt"
	"image"
)

func main() {
	// 创建一个 100x100 的 RGBA 图像
	m := image.NewRGBA(image.Rect(0, 0, 100, 100))

	// 打印图像的边界
	fmt.Println(m.Bounds())

	// 打印 (0,0) 点的 RGBA 值
	fmt.Println(m.At(0, 0).RGBA())
}
```

## 练习：图像

返回一个 `image.Image` 的实现而非一个数据切片。

定义你自己的 `Image` 类型，实现[必要的方法](https://go-zh.org/pkg/image/#Image)并调用 `pic.ShowImage`。

`Bounds` 应当返回一个 `image.Rectangle` ，例如 `image.Rect(0, 0, w, h)`。

`ColorModel` 应当返回 `color.RGBAModel`。

`At` 应当返回一个颜色。上一个图片生成器的值 `v` 对应于此次的 `color.RGBA{v, v, 255, 255}`。

```go
package main

import (
	"image"
	"image/color"
	"golang.org/x/tour/pic"
)

type Image struct {
	width, height int
}

func (img Image) Bounds() image.Rectangle {
	return image.Rect(0, 0, img.width, img.height)
}

func (img Image) ColorModel() color.Model {
	return color.RGBAModel
}

func (img Image) At(x, y int) color.Color {
	v := uint8((x ^ y) % 256) // 随便一个生成颜色的算法，可以修改
	return color.RGBA{v, v, 255, 255}
}

func main() {
	m := Image{256, 256}
	pic.ShowImage(m)
}
```