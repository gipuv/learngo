# 泛型

## 类型参数

可以使用类型参数编写 `Go` 函数来处理多种类型。 函数的类型参数出现在函数参数之前的方括号之间。

```go
func Index[T comparable](s []T, x T) int
```

此声明意味着 `s` 是满足内置约束 `comparable` 的任何类型 `T` 的切片。 `x` 也是相同类型的值。

`comparable` 是一个有用的约束，它能让我们对任意满足该类型的值使用 `==` 和 `!=` 运算符。在此示例中，我们使用它将值与所有切片元素进行比较，直到找到匹配项。 该 `Index` 函数适用于任何支持比较的类型。 

```go
package main

import "fmt"

// Index 返回值 x 在切片 s 中首次出现的下标，若未找到则返回 -1。
// 这里使用了泛型，类型参数 T 必须满足 comparable 约束，
// 因此可以使用 == 运算符来比较两个 T 类型的值。
func Index[T comparable](s []T, x T) int {
	for i, v := range s {
		// v 和 x 的类型都是 T，因为 T 满足 comparable，可以直接比较
		if v == x {
			return i // 找到则返回下标
		}
	}
	return -1 // 未找到返回 -1
}

func main() {
	// 在整数切片中查找 15
	si := []int{10, 20, 15, -10}
	fmt.Println(Index(si, 15)) // 输出 2

	// 在字符串切片中查找 "hello"
	ss := []string{"foo", "bar", "baz"}
	fmt.Println(Index(ss, "hello")) // 输出 -1，未找到
}
```

## 泛型类型

除了泛型函数之外，`Go` 还支持泛型类型。 类型可以使用类型参数进行参数化，这对于实现通用数据结构非常有用。

此示例展示了能够保存任意类型值的单链表的简单类型声明。

作为练习，请为此链表的实现添加一些功能。 

```go
package main

import (
	"fmt"
	"strings"
)

// List 表示一个可以保存任意类型值的单链表。
type List[T any] struct {
	next *List[T]
	val  T
}

// Push 在链表头部插入一个新元素，返回新链表头。
func (l *List[T]) Push(v T) *List[T] {
	return &List[T]{next: l, val: v}
}

// Len 返回链表长度。
func (l *List[T]) Len() int {
	count := 0
	for curr := l; curr != nil; curr = curr.next {
		count++
	}
	return count
}

// String 返回链表内容的字符串表示，方便打印。
func (l *List[T]) String() string {
	var sb strings.Builder
	sb.WriteString("[")
	for curr := l; curr != nil; curr = curr.next {
		sb.WriteString(fmt.Sprintf("%v", curr.val))
		if curr.next != nil {
			sb.WriteString(" -> ")
		}
	}
	sb.WriteString("]")
	return sb.String()
}

func main() {
	var list *List[int] // 空链表，元素类型为 int

	list = list.Push(10)
	list = list.Push(20)
	list = list.Push(30)

	fmt.Println("链表长度:", list.Len()) // 输出: 链表长度: 3
	fmt.Println("链表内容:", list)       // 输出: 链表内容: [30 -> 20 -> 10]
}
```