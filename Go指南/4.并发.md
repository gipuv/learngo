# 并发

## Go 协程

`Go` 程（`goroutine`）是由 `Go` 运行时管理的轻量级线程。

```go
go f(x, y, z)
```

会启动一个新的 `Go` 协程并执行

```go
f(x, y, z)
```

`f`, `x`, `y` 和 `z` 的求值发生在当前的 `Go` 协程中，而 `f` 的执行发生在新的 `Go` 协程中。

`Go` 程在相同的地址空间中运行，因此在访问共享的内存时必须进行同步。`sync` 包提供了这种能力，不过在 Go 中并不经常用到，因为还有其它的办法（见下一页）。 

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

func say(s string, wg *sync.WaitGroup) {
	defer wg.Done()
	for i := 0; i < 5; i++ {
		time.Sleep(100 * time.Millisecond)
		fmt.Println(s)
	}
}

func main() {
	var wg sync.WaitGroup
	wg.Add(1)
	go say("world", &wg)

	wg.Add(1)
	go say("hello", &wg)

	wg.Wait() // 等待所有 goroutine 完成
}
```

## 信道

信道是带有类型的管道，你可以通过它用信道操作符 `<-` 来发送或者接收值。

```go
ch <- v    // 将 v 发送至信道 ch。
v := <-ch  // 从 ch 接收值并赋予 v。
```

（“箭头”就是数据流的方向。）

和映射与切片一样，信道在使用前必须创建：

```go
ch := make(chan int)
```

默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 `Go` 程可以在没有显式的锁或竞态变量的情况下进行同步。

以下示例对切片中的数进行求和，将任务分配给两个 `Go` 程。一旦两个 `Go` 程完成了它们的计算，它就能算出最终的结果。 

```go
package main

import "fmt"

func sum(s []int, c chan int) {
	sum := 0
	for _, v := range s {
		sum += v
	}
	c <- sum // 发送 sum 到 c，将计算结果发送到信道 c
}

func main() {
    s := []int{7, 2, 8, -9, 4, 0}

	c := make(chan int) // 创建一个整型信道
	go sum(s[:len(s)/2], c)  // 开启第一个 goroutine，计算前半部分切片和
	go sum(s[len(s)/2:], c)  // 开启第二个 goroutine，计算后半部分切片和

	x, y := <-c, <-c  // 从信道接收两个结果，接收操作会阻塞直到收到数据

	fmt.Println(x, y, x+y) // 输出两个部分的和以及它们的总和
}
```

```go
// 使用 sync.Mutex 保护共享变量
var mu sync.Mutex
var balance int

func deposit(amount int) {
    mu.Lock()
    balance += amount
    mu.Unlock()
}
```

```go
// 使用信道来传递数据，不用显式锁
deposits := make(chan int)

go func() {
    balance := 0
    for amount := range deposits {
        balance += amount
        fmt.Println("Balance:", balance)
    }
}()

deposits <- 100
deposits <- 200
close(deposits)
```

你可以把信道看作 Go 的**首选并发工具**

### 三个常见的用信道实现并发同步的示例

* 利用信道实现任务等待（类似 `WaitGroup`）

```go
package main

import (
	"fmt"
	"time"
)

func worker(id int, done chan bool) {
	fmt.Printf("Worker %d starting\n", id)
	time.Sleep(time.Second) // 模拟工作
	fmt.Printf("Worker %d done\n", id)
	done <- true // 任务完成，发送信号
}

func main() {
	done := make(chan bool)
	numWorkers := 3

	for i := 1; i <= numWorkers; i++ {
		go worker(i, done)
	}

	// 等待所有 worker 发送完成信号
	for i := 0; i < numWorkers; i++ {
		<-done
	}

	fmt.Println("All workers done")
}
```

* 使用信道做生产者-消费者

```go
package main

import (
	"fmt"
	"time"
)

func producer(ch chan<- int) {
	for i := 1; i <= 5; i++ {
		fmt.Println("Producing", i)
		ch <- i // 发送数据
		time.Sleep(300 * time.Millisecond)
	}
	close(ch) // 生产结束，关闭信道
}

func consumer(ch <-chan int) {
	for v := range ch { // 从信道接收，直到信道关闭
		fmt.Println("Consuming", v)
	}
	fmt.Println("Consumer done")
}

func main() {
	ch := make(chan int)
	go producer(ch)
	consumer(ch)
}
```

* 使用信道进行超时控制

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	ch := make(chan int)

	go func() {
		time.Sleep(2 * time.Second) // 模拟耗时操作
		ch <- 42
	}()

	select {
	case res := <-ch:
		fmt.Println("Received:", res)
	case <-time.After(1 * time.Second):
		fmt.Println("Timeout: no result within 1 second")
	}
}
```

## 带缓冲的信道

信道可以是 **带缓冲的**。将缓冲长度作为第二个参数提供给 make 来初始化一个带缓冲的信道：

```go
ch := make(chan int, 100)
```

仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。

```go
package main

import "fmt"

func main() {
	ch := make(chan int, 2)
	ch <- 1
	ch <- 2
	fmt.Println(<-ch)
	fmt.Println(<-ch)
}
```

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	ch := make(chan int, 2)

	ch <- 1
	fmt.Println("Sent 1")
	ch <- 2
	fmt.Println("Sent 2")

	// 这里缓冲区已经满了，下面的发送会阻塞
	fmt.Println("Trying to send 3...")
	go func() {
		ch <- 3
		fmt.Println("Sent 3")
	}()

	time.Sleep(time.Second) // 等待 1 秒观察是否有输出

	// 从信道接收一个值，为后续发送释放缓冲区空间
	fmt.Println("Received:", <-ch)

	time.Sleep(time.Second) // 再等 1 秒，观察发送3是否完成
}
```

## range 和 close

发送者可通过 `close` 关闭一个信道来表示没有需要发送的值了。接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭：若没有值可以接收且信道已被关闭，那么在执行完

```go
v, ok := <-ch
```

此时 `ok` 会被设置为 `false`。

循环 `for i := range c `会不断从信道接收值，直到它被关闭。

**注意**： 只应由发送者关闭信道，而不应油接收者关闭。向一个已经关闭的信道发送数据会引发程序 `panic`。

**还要注意**： 信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个 range 循环。 

```go
package main

import (
	"fmt"
)

// fibonacci 函数向信道 c 发送 n 个斐波那契数列的值
func fibonacci(n int, c chan int) {
	x, y := 0, 1
	for i := 0; i < n; i++ {
		c <- x // 发送当前的斐波那契数值到信道
		x, y = y, x+y
	}
	close(c) // 发送完成后关闭信道，通知接收者没有更多数据
}

func main() {
	c := make(chan int, 10)    // 创建一个容量为10的带缓冲信道
	go fibonacci(cap(c), c)    // 启动一个goroutine计算并发送斐波那契数

	// range 会不断从信道 c 接收数据，直到信道被关闭且数据读完
	for i := range c {
		fmt.Println(i)
	}
}
```

重点说明：

* `close(c)` 是由发送方调用，表示不会再往信道里发送数据了。

* `for i := range c `循环会在信道关闭且数据都接收完后自动结束。

* 不应该让接收方关闭信道，否则可能会引发 `panic`。

* 关闭信道后，接收方用 `<-c` 读取时，若已无数据，会立即返回零值，同时第二个返回值 `ok` 为 `false`。

你可以试着把接收循环改写成带判断的形式

```go
for {
    v, ok := <-c
    if !ok { // 信道关闭，退出循环
        break
    }
    fmt.Println(v)
}
```

## select 语句

`select` 语句使一个 `Go` 程可以等待多个通信操作。

`select` 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。

```go
package main

import "fmt"

// fibonacci 函数向信道 c 发送斐波那契数列数字，
// 同时监听 quit 信道来决定何时退出。
func fibonacci(c, quit chan int) {
	x, y := 0, 1
	for {
		select {
		case c <- x:  // 如果 c 信道准备好，发送当前斐波那契数
			x, y = y, x+y
		case <-quit:  // 如果 quit 信道有数据（即收到退出信号）
			fmt.Println("quit")
			return // 退出函数，结束协程
		}
	}
}

func main() {
	c := make(chan int)    // 用于传输斐波那契数的信道
	quit := make(chan int) // 用于通知退出的信道

	// 启动一个匿名协程，负责从 c 信道接收数据并打印
	// 打印完 10 个斐波那契数后，发送退出信号到 quit 信道
	go func() {
		for i := 0; i < 10; i++ {
			fmt.Println(<-c) // 从 c 信道接收斐波那契数并打印
		}
		quit <- 0 // 发送退出信号给 fibonacci
	}()

	// 主协程执行 fibonacci，直到收到 quit 信号退出
	fibonacci(c, quit)
}
```

这是典型的用 `select` 实现 `协程间通信和退出通知` 的模式。

### 其他相关

* 多路复用：同时监听多个输入信道，优先处理任意有数据的信道

同时监听多个信道并带超时的典型场景

```go
package main

import (
	"fmt"
	"time"
)

func sendData(name string, c chan string, delay time.Duration) {
	for i := 0; ; i++ {
		time.Sleep(delay)
		c <- fmt.Sprintf("%s: %d", name, i)
	}
}

func main() {
	c1 := make(chan string)
	c2 := make(chan string)

	go sendData("chan1", c1, 500*time.Millisecond)
	go sendData("chan2", c2, 700*time.Millisecond)

	for {
		select {
		case msg1 := <-c1:
			fmt.Println("Received from c1:", msg1)
		case msg2 := <-c2:
			fmt.Println("Received from c2:", msg2)
		case <-time.After(1 * time.Second): // 超时1秒没有收到数据
			fmt.Println("timeout, no messages received")
			return
		}
	}
}
```

* 动态信道选择（实现限流，控制最大并发数）

于信道和协程的并发限流模式

```go
package main

import (
	"fmt"
	"time"
)

func worker(id int, jobs <-chan int, results chan<- int) {
	for j := range jobs {
		fmt.Printf("worker %d started job %d\n", id, j)
		time.Sleep(time.Second) // 模拟耗时任务
		fmt.Printf("worker %d finished job %d\n", id, j)
		results <- j * 2
	}
}

func main() {
	jobs := make(chan int, 5)
	results := make(chan int, 5)

	// 启动 3 个 worker（限制最大并发为3）
	for w := 1; w <= 3; w++ {
		go worker(w, jobs, results)
	}

	// 发送 5 个任务
	for j := 1; j <= 5; j++ {
		jobs <- j
	}
	close(jobs)

	// 收集结果
	for a := 1; a <= 5; a++ {
		fmt.Println("result:", <-results)
	}
}
```


* 使用 select 实现非阻塞发送和接收

适用于需要轮询或尝试发送接收而不等待的场景

```go
package main

import "fmt"

func main() {
	ch := make(chan int, 1)

	select {
	case ch <- 1: // 尝试发送
		fmt.Println("sent 1")
	default:
		fmt.Println("send failed")
	}

	select {
	case v := <-ch: // 尝试接收
		fmt.Println("received", v)
	default:
		fmt.Println("receive failed")
	}

	select {
	case v := <-ch:
		fmt.Println("received", v)
	default:
		fmt.Println("receive failed again")
	}
}
```

* 结合 time.Ticker 实现定时任务

适合周期性任务和优雅退出的组合

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	ticker := time.NewTicker(500 * time.Millisecond)
	defer ticker.Stop()

	done := make(chan bool)

	go func() {
		time.Sleep(3 * time.Second)
		done <- true
	}()

	for {
		select {
		case t := <-ticker.C:
			fmt.Println("Tick at", t)
		case <-done:
			fmt.Println("Done!")
			return
		}
	}
}
```

## 默认选择

当 `select` 中的其它分支都没有准备好时，`default` 分支就会执行。

为了在尝试发送或者接收时不发生阻塞，可使用 `default` 分支：

```go
select {
case i := <-c:
    // 使用 i
default:
    // 从 c 中接收会阻塞时执行
}
```

## 练习：等价二叉查找树

不同二叉树的叶节点上可以保存相同的值序列。例如，以下两个二叉树都保存了序列 `1，1，2，3，5，8，13`。

![](../assets/images/tree.png)

在大多数语言中，检查两个二叉树是否保存了相同序列的函数都相当复杂。 我们将使用 `Go` 的并发和信道来编写一个简单的解法。

本例使用了 `tree` 包，它定义了类型：

```go
type Tree struct {
    Left  *Tree
    Value int
    Right *Tree
}
```

1. 实现 `Walk` 函数。

2. 测试 `Walk` 函数。

函数 `tree.New(k)` 用于构造一个随机结构的已排序二叉查找树，它保存了值 `k, 2k, 3k, ..., 10k`。

创建一个新的信道 `ch` 并且对其进行步进：

```go
go Walk(tree.New(1), ch)
```

然后从信道中读取并打印 `10` 个值。应当是数字 `1, 2, 3, ..., 10`.

3. 用 `Walk` 实现 `Same` 函数来检测 `t1` 和 `t2` 是否存储了相同的值。

4. 测试 `Same` 函数。

`Same(tree.New(1), tree.New(1)) `应当返回 `true，而` `Same(tree.New(1), tree.New(2))` 应当返回 `false`。

`Tree` 的[文档](https://pkg.go.dev/golang.org/x/tour/tree#Tree)可在这里找到。 

```go
package main

import (
	"fmt"
	"golang.org/x/tour/tree"
)

// Walk 遍历二叉树 t，并将所有节点值按顺序发送到信道 ch。
func Walk(t *tree.Tree, ch chan int) {
	if t == nil {
		// 递归终止条件，当前节点为空，返回。
		return
	}
	// 递归遍历左子树
	Walk(t.Left, ch)
	// 发送当前节点的值到信道
	ch <- t.Value
	// 递归遍历右子树
	Walk(t.Right, ch)
}

// Same 判断两棵树 t1 和 t2 是否包含相同的值序列
func Same(t1, t2 *tree.Tree) bool {
	ch1 := make(chan int)
	ch2 := make(chan int)

	// 并发遍历第一棵树，遍历完成后关闭信道ch1
	go func() {
		Walk(t1, ch1)
		close(ch1)
	}()

	// 并发遍历第二棵树，遍历完成后关闭信道ch2
	go func() {
		Walk(t2, ch2)
		close(ch2)
	}()

	// 循环从两个信道中读取值进行比较
	for {
		v1, ok1 := <-ch1 // 从ch1接收，ok1表示信道是否关闭
		v2, ok2 := <-ch2 // 从ch2接收，ok2同理

		// 如果一个信道关闭了，而另一个没有，说明两棵树长度不一样，返回false
		if ok1 != ok2 {
			return false
		}

		// 两个信道都关闭，说明所有值均比较完毕且相等，跳出循环
		if !ok1 {
			break
		}

		// 当前值不同，说明两棵树不相等，返回false
		if v1 != v2 {
			return false
		}
	}

	// 所有值均相同，返回true
	return true
}

func main() {
	ch := make(chan int)

	// 启动一个 goroutine 遍历树并将值发送到信道
	go func() {
		Walk(tree.New(1), ch)
		close(ch) // 遍历结束，关闭信道，通知接收方没有更多数据了
	}()

	// 从信道中接收并打印遍历值，应该是1到10
	fmt.Print("Walk tree.New(1): ")
	for v := range ch {
		fmt.Print(v, " ")
	}
	fmt.Println()

	// 测试 Same 函数
	fmt.Println("Same(tree.New(1), tree.New(1)) =", Same(tree.New(1), tree.New(1))) // true
	fmt.Println("Same(tree.New(1), tree.New(2)) =", Same(tree.New(1), tree.New(2))) // false
}
```

## sync.Mutex

我们已经看到信道非常适合在各个 `Go` 程间进行通信。

但是如果我们并不需要通信呢？比如说，若我们只是想保证每次只有一个 `Go` 程能够访问一个共享的变量，从而避免冲突？

这里涉及的概念叫做 **互斥（mutual*exclusion）** ，我们通常使用 **互斥锁（Mutex）** 这一数据结构来提供这种机制。

`Go` 标准库中提供了 `sync.Mutex` 互斥锁类型及其两个方法：

    `Lock`
    `Unlock`

我们可以通过在代码前调用 `Lock` 方法，在代码后调用 `Unlock` 方法来保证一段代码的互斥执行。参见 `Inc` 方法。

我们也可以用 `defer` 语句来保证互斥锁一定会被解锁。参见 `Value` 方法。

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

// SafeCounter 是一个并发安全的计数器，
// 使用互斥锁保护内部的 map 结构，避免竞态条件。
type SafeCounter struct {
	mu sync.Mutex   // 互斥锁，保护下面的 map
	v  map[string]int
}

// Inc 给指定的 key 对应的计数加一。
// 使用 Lock 和 Unlock 确保同一时刻只有一个 goroutine 可以操作 map，防止数据竞争。
func (c *SafeCounter) Inc(key string) {
	c.mu.Lock()         // 加锁
	c.v[key]++          // 安全地修改共享数据
	c.mu.Unlock()       // 解锁
}

// Value 返回指定 key 的计数值。
// 这里使用 defer 确保函数退出时一定会解锁，避免死锁。
func (c *SafeCounter) Value(key string) int {
	c.mu.Lock()         // 加锁
	defer c.mu.Unlock() // 保证在函数退出时解锁
	return c.v[key]     // 读取共享数据
}

func main() {
	c := SafeCounter{v: make(map[string]int)}

	// 启动 1000 个 goroutine 并发调用 Inc，模拟并发写操作
	for i := 0; i < 1000; i++ {
		go c.Inc("somekey")
	}

	// 等待 1 秒，确保所有 goroutine 执行完成
	time.Sleep(time.Second)

	// 读取最终计数值，应该是 1000
	fmt.Println(c.Value("somekey"))
}
```


## 练习：Web 爬虫

在这个练习中，我们将会使用 `Go` 的并发特性来并行化一个 `Web` 爬虫。

修改 `Crawl` 函数来并行地抓取 `URL`，并且保证不重复。

**提示：** 你可以用一个 `map` 来缓存已经获取的 `URL`，但是要注意 `map` 本身并不是并发安全的！

```go
package main

import (
	"fmt"
	"sync"
)

// Fetcher 接口定义
type Fetcher interface {
	Fetch(url string) (body string, urls []string, err error)
}

// SafeVisited 用于并发安全地记录已经访问过的 URL
type SafeVisited struct {
	mu      sync.Mutex
	visited map[string]bool
}

// Visited 查询是否访问过某个 URL
func (v *SafeVisited) Visited(url string) bool {
	v.mu.Lock()
	defer v.mu.Unlock()
	return v.visited[url]
}

// SetVisited 标记某个 URL 已访问
func (v *SafeVisited) SetVisited(url string) {
	v.mu.Lock()
	v.visited[url] = true
	v.mu.Unlock()
}

// Crawl 并发爬取 URL，保证不重复访问
func Crawl(url string, depth int, fetcher Fetcher, visited *SafeVisited, wg *sync.WaitGroup) {
	defer wg.Done() // 本次爬取结束时通知 WaitGroup

	if depth <= 0 {
		return
	}

	// 如果已经访问过该 URL，则直接返回，避免重复爬取
	if visited.Visited(url) {
		return
	}

	// 标记访问
	visited.SetVisited(url)

	// 抓取页面内容和链接
	body, urls, err := fetcher.Fetch(url)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Printf("found: %s %q\n", url, body)

	// 对子链接递归调用 Crawl，开启新的 goroutine 并将 WaitGroup 计数加 1
	for _, u := range urls {
		wg.Add(1)
		go Crawl(u, depth-1, fetcher, visited, wg)
	}
}

func main() {
	visited := &SafeVisited{visited: make(map[string]bool)}
	var wg sync.WaitGroup

	wg.Add(1)
	Crawl("https://golang.org/", 4, fetcher, visited, &wg)

	// 等待所有爬取完成
	wg.Wait()
}

// fakeFetcher 用于模拟抓取器
type fakeFetcher map[string]*fakeResult

type fakeResult struct {
	body string
	urls []string
}

func (f fakeFetcher) Fetch(url string) (string, []string, error) {
	if res, ok := f[url]; ok {
		return res.body, res.urls, nil
	}
	return "", nil, fmt.Errorf("not found: %s", url)
}

// 预定义的模拟数据
var fetcher = fakeFetcher{
	"https://golang.org/": &fakeResult{
		"The Go Programming Language",
		[]string{
			"https://golang.org/pkg/",
			"https://golang.org/cmd/", // 之前没定义的 URL
		},
	},
	"https://golang.org/pkg/": &fakeResult{
		"Packages",
		[]string{
			"https://golang.org/",
			"https://golang.org/cmd/",
			"https://golang.org/pkg/fmt/",
			"https://golang.org/pkg/os/",
		},
	},
	"https://golang.org/pkg/fmt/": &fakeResult{
		"Package fmt",
		[]string{
			"https://golang.org/",
			"https://golang.org/pkg/",
		},
	},
	"https://golang.org/pkg/os/": &fakeResult{
		"Package os",
		[]string{
			"https://golang.org/",
			"https://golang.org/pkg/",
		},
	},
	"https://golang.org/cmd/": &fakeResult{
		"Commands",
		[]string{
			"https://golang.org/",
		},
	},
}
```
